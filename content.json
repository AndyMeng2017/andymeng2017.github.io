{"meta":{"title":"DaDa GOUGOU","subtitle":"博客","description":"How many roads must a man walk down.","author":"John Doe|DaDa GOUGOU","url":"http://andymeng2017.github.io","root":"/"},"pages":[{"title":"about","date":"2019-08-09T11:43:59.000Z","updated":"2021-06-10T09:07:44.990Z","comments":false,"path":"about/index.html","permalink":"http://andymeng2017.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-09T11:41:20.000Z","updated":"2021-06-10T09:07:44.990Z","comments":false,"path":"categories/index.html","permalink":"http://andymeng2017.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-09T11:41:36.000Z","updated":"2021-06-10T09:07:44.993Z","comments":false,"path":"tags/index.html","permalink":"http://andymeng2017.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-06-10T09:07:44.988Z","updated":"2021-06-10T09:07:44.988Z","comments":true,"path":"2021/06/10/hello-world/","link":"","permalink":"http://andymeng2017.github.io/2021/06/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Spring Boot系列（二）Spring-data-jpa 事务机制","slug":"spring boot/Spring Boot系列（二）Spring-data-jpa事务机制","date":"2019-08-26T11:35:16.000Z","updated":"2021-06-10T09:07:44.990Z","comments":true,"path":"2019/08/26/spring boot/Spring Boot系列（二）Spring-data-jpa事务机制/","link":"","permalink":"http://andymeng2017.github.io/2019/08/26/spring boot/Spring Boot系列（二）Spring-data-jpa事务机制/","excerpt":"Spring-data-jpa 事务机制什么是事务？我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。 事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务。 快速入门在Spring Boot中，当我们使用了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。","text":"Spring-data-jpa 事务机制什么是事务？我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。 事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务。 快速入门在Spring Boot中，当我们使用了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.sinovoice.hcicloud.service;import com.sinovoice.hcicloud.dto.SendSuccessLog;import com.sinovoice.hcicloud.service.repository.SendSuccessLogRepository;import com.sinovoice.hcicloud.web.controller.metrics.DemoController;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 测试的时候，要注释掉 MyConstraintValidator#helloService 依赖，不然会失败 * * @Author: mhn * @Date: 2019/6/19 22:49 * @Version 1.0 * @Software: IntelliJ IDEA */@Slf4j@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class SendSuccessLogServiceJpaTest &#123; @Autowired private SendSuccessLogServiceJpa sendSuccessLogServiceJpa; @Test public void query() throws Exception &#123; SendSuccessLog sendSuccessLog = sendSuccessLogServiceJpa.getSysConfig(\"8a80805e6ca8b9bd016ca8b9f4ee0000\"); System.err.println(sendSuccessLog.getVersion()); &#125; @Test public void update() throws Exception &#123; SendSuccessLog sendSuccessLog = sendSuccessLogServiceJpa.getSysConfig(\"8a80805e6ca8b9bd016ca8b9f4ee0000\"); sendSuccessLog.setRemark1(\"0\"); System.err.println(\"开始保存\"); sendSuccessLogServiceJpa.saveSysConfig(sendSuccessLog); &#125; @Test public void update1() throws Exception &#123; SendSuccessLog sendSuccessLog = sendSuccessLogServiceJpa.getSysConfig(\"8a80805e6ca8b9bd016ca8b9f4ee0000\"); sendSuccessLog.setRemark1(\"1\"); System.err.println(\"开始保存\"); sendSuccessLogServiceJpa.testSysConfig1(sendSuccessLog); &#125; @Test public void update2() throws Exception &#123; SendSuccessLog sendSuccessLog = sendSuccessLogServiceJpa.getSysConfig(\"8a80805e6ca8b9bd016ca8b9f4ee0000\"); sendSuccessLog.setRemark1(\"2\"); System.err.println(\"开始保存\"); sendSuccessLogServiceJpa.testSysConfig2(sendSuccessLog); &#125; @Test public void update4() throws Exception &#123; SendSuccessLog sendSuccessLog = sendSuccessLogServiceJpa.getSysConfig(\"8a80805e6ca8b9bd016ca8b9f4ee0000\"); sendSuccessLog.setRemark1(\"5\"); System.err.println(\"开始保存\"); sendSuccessLogServiceJpa.testSysConfig4(sendSuccessLog); &#125;&#125; 创建实体略 创建数据访问接口1234567891011121314151617181920212223package com.sinovoice.hcicloud.service.repository;import com.sinovoice.hcicloud.dto.SendSuccessLog;import com.sinovoice.hcicloud.dto.User;import com.sinovoice.hcicloud.web.aspect.ExceptionRetry;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.orm.ObjectOptimisticLockingFailureException;import org.springframework.stereotype.Repository;/** * @Author: mhn * @Date: 2019/6/19 23:11 * @Version 1.0 * @Software: IntelliJ IDEA */@Repositorypublic interface SendSuccessLogRepository extends JpaRepository&lt;SendSuccessLog, String&gt; &#123; SendSuccessLog findByBusinessId(String businessId);&#125; 定义service层接口12345678910111213141516171819202122232425262728package com.sinovoice.hcicloud.service;import com.sinovoice.hcicloud.dto.SendSuccessLog;/** * @Author: mhn * @Date: 2019/7/9 18:09 * @Version 1.0 * @Software: IntelliJ IDEA */public interface SendSuccessLogServiceJpa &#123; public SendSuccessLog getSysConfig(String uuid); public SendSuccessLog saveSysConfig(SendSuccessLog entity); public void testSysConfig1(SendSuccessLog entity) throws Exception; public void testSysConfig2(SendSuccessLog entity) throws Exception; public void testSysConfig3(SendSuccessLog entity) throws Exception; public void testSysConfig4(SendSuccessLog entity) throws Exception; public void testSysConfig5(SendSuccessLog entity) throws Exception;&#125; 定义service层接口实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.sinovoice.hcicloud.service.impl;import com.sinovoice.hcicloud.dto.SendSuccessLog;import com.sinovoice.hcicloud.service.SendSuccessLogServiceJpa;import com.sinovoice.hcicloud.service.repository.SendSuccessLogRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.Date;import java.util.Optional;/** * @Author: mhn * @Date: 2019/7/9 18:10 * @Version 1.0 * @Software: IntelliJ IDEA */@Servicepublic class SendSuccessLogServiceJpaImpl implements SendSuccessLogServiceJpa &#123; @Autowired private SendSuccessLogRepository sendSuccessLogRepository; @Override public SendSuccessLog getSysConfig(String uuid) &#123; Optional&lt;SendSuccessLog&gt; sendSuccessLogOptional = sendSuccessLogRepository.findById(uuid); return sendSuccessLogOptional.get(); &#125; @Override public SendSuccessLog saveSysConfig(SendSuccessLog entity) &#123; if(entity.getOpenApiCreateTime()==null)&#123; entity.setOpenApiCreateTime(new Date()); &#125; return sendSuccessLogRepository.save(entity); &#125; /** * 不会回滚 * 由于 @Transactional 注解默认不捕获 检查性异常 * @param entity * @throws Exception */ @Override @Transactional public void testSysConfig1(SendSuccessLog entity) throws Exception &#123; this.saveSysConfig(entity); throw new Exception(\"sysconfig error\"); &#125; /** * =================================== 一个方法调用另一个方法（一） ================================ * 方法 testSysConfig2 调用 testSysConfig3 ，因为方法 testSysConfig2 开启了事务，所以这两个方法都在事务中。 * 不会回滚 * 方法 testSysConfig2 的注解 @Transactional 默认不捕获 检查性异常 * @param entity * @throws Exception */ @Override @Transactional public void testSysConfig2(SendSuccessLog entity) throws Exception &#123; //事务仍然会被提交 this.testSysConfig3(entity); throw new Exception(\"sysconfig error\"); &#125; @Override @Transactional(rollbackFor = Exception.class) public void testSysConfig3(SendSuccessLog entity) throws Exception &#123; this.saveSysConfig(entity); &#125; /** * =================================== 一个方法调用另一个方法（二） ================================ * 方法 testSysConfig4 调用 testSysConfig5 ，因为方法 testSysConfig4 没有开启事务，所以这两个方法不在事务中。 * 不会回滚 * 方法 testSysConfig4 没有加事务注解，会导致 testSysConfig5 也没在事务中 * @param entity * @throws Exception */ @Override public void testSysConfig4(SendSuccessLog entity) throws Exception &#123; //事务仍然会被提交 this.testSysConfig5(entity); throw new Exception(\"sysconfig error\"); &#125; @Override @Transactional(rollbackFor = Exception.class) public void testSysConfig5(SendSuccessLog entity) throws Exception &#123; this.saveSysConfig(entity); throw new Exception(\"sysconfig error\"); &#125;&#125; 上述定义了2种类型的事务示例 展示了不会回滚的3种情况 一个方法testSysConfig1方法中，添加注解@Transactional，出现Exception异常不会回滚，因为默认只对RuntimeException回滚 两个方法1.testSysConfig2方法中，开启事务注解@Transactional，testSysConfig3方法中也开启事务注解@Transactional，同时捕获Exception异常。这里的两个方法会产生事务传递，由于testSysConfig2方法开启事务，所以这两个方法处于同一个事务中。但是testSysConfig2方法并没有捕获Exception异常，这里依然不会回滚 2.testSysConfig4方法和testSysConfig5方法中都没有开启事务，所以这两个方法不在事务中，不会回滚 对于常用的Spring的@Transactional的总结如下： 异常在A方法内抛出，则A方法就得加注解 多个方法嵌套调用，如果都有 @Transactional 注解，则产生事务传递，默认 Propagation.REQUIRED 如果注解上只写 @Transactional 默认只对 RuntimeException 回滚，而非 Exception 进行回滚 如果要对 checked Exceptions 进行回滚，则需要 @Transactional(rollbackFor = Exception.class) 事务详解指定不同的事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释： 事务管理器Spring-data-jpa支持新增对第一数据源的JPA配置，注意两处注释的地方，用于指定数据源对应的Entity实体和Repository定义位置，用@Primary区分主数据源。 123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef=\"entityManagerFactoryPrimary\", transactionManagerRef=\"transactionManagerPrimary\", basePackages= &#123; \"com.didispace.domain.p\" &#125;) //设置Repository所在位置public class PrimaryConfig &#123; @Autowired @Qualifier(\"primaryDataSource\") private DataSource primaryDataSource; @Primary @Bean(name = \"entityManagerPrimary\") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactoryPrimary(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = \"entityManagerFactoryPrimary\") public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(primaryDataSource) .properties(getVendorProperties(primaryDataSource)) .packages(\"com.didispace.domain.p\") //设置实体类所在位置 .persistenceUnit(\"primaryPersistenceUnit\") .build(); &#125; @Autowired private JpaProperties jpaProperties; private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Primary @Bean(name = \"transactionManagerPrimary\") public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject()); &#125;&#125; 新增对第二数据源的JPA配置，内容与第一数据源类似，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839@Configuration@EnableTransactionManagement@EnableJpaRepositories( entityManagerFactoryRef=\"entityManagerFactorySecondary\", transactionManagerRef=\"transactionManagerSecondary\", basePackages= &#123; \"com.didispace.domain.s\" &#125;) //设置Repository所在位置public class SecondaryConfig &#123; @Autowired @Qualifier(\"secondaryDataSource\") private DataSource secondaryDataSource; @Bean(name = \"entityManagerSecondary\") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return entityManagerFactorySecondary(builder).getObject().createEntityManager(); &#125; @Bean(name = \"entityManagerFactorySecondary\") public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary (EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(secondaryDataSource) .properties(getVendorProperties(secondaryDataSource)) .packages(\"com.didispace.domain.s\") //设置实体类所在位置 .persistenceUnit(\"secondaryPersistenceUnit\") .build(); &#125; @Autowired private JpaProperties jpaProperties; private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Bean(name = \"transactionManagerSecondary\") PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject()); &#125;&#125; 完成了以上配置之后，主数据源的实体和数据访问对象位于：com.didispace.domain.p，次数据源的实体和数据访问接口位于：com.didispace.domain.s。 分别在这两个package下创建各自的实体和数据访问接口 主数据源下，创建User实体和对应的Repository接口 1234567891011121314151617181920212223242526@Entitypublic class User &#123; @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; // 省略getter、setter&#125;public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 从数据源下，创建Message实体和对应的Repository接口 1234567891011121314151617181920212223242526@Entitypublic class Message &#123; @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private String content; public Message()&#123;&#125; public Message(String name, String content) &#123; this.name = name; this.content = content; &#125; // 省略getter、setter&#125;public interface MessageRepository extends JpaRepository&lt;Message, Long&gt; &#123;&#125; 接下来通过测试用例来验证使用这两个针对不同数据源的配置进行数据操作。 1234567891011121314151617181920212223242526272829@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(Application.class)public class ApplicationTests &#123; @Autowired private UserRepository userRepository; @Autowired private MessageRepository messageRepository; @Test public void test() throws Exception &#123; userRepository.save(new User(\"aaa\", 10)); userRepository.save(new User(\"bbb\", 20)); userRepository.save(new User(\"ccc\", 30)); userRepository.save(new User(\"ddd\", 40)); userRepository.save(new User(\"eee\", 50)); Assert.assertEquals(5, userRepository.findAll().size()); messageRepository.save(new Message(\"o1\", \"aaaaaaaaaa\")); messageRepository.save(new Message(\"o2\", \"bbbbbbbbbb\")); messageRepository.save(new Message(\"o3\", \"cccccccccc\")); Assert.assertEquals(3, messageRepository.findAll().size()); &#125;&#125; 隔离级别隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。 我们可以看org.springframework.transaction.annotation.Isolation枚举类中定义了五个表示隔离级别的值： 1234567public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);&#125; DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。 READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 指定方法：通过使用isolation属性设置，例如： 1@Transactional(isolation = Isolation.DEFAULT) 传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 我们可以看org.springframework.transaction.annotation.Propagation枚举类中定义了6个表示传播行为的枚举值： 123456789public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6);&#125; REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。 指定方法：通过使用propagation属性设置，例如： 1@Transactional(propagation = Propagation.REQUIRED) 事务配置示例Spring默认情况下会对运行期例外(RunTimeException)，即uncheck异常，进行事务回滚。 如果遇到checked异常就不回滚。如何改变默认规则： 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class) 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class) 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED) 注意事项 在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上 。 @Transactional 注解只能应用到 public 可见度的方法上 。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创 建。 如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。注解@Transactional cglib与java动态代理最大区别是代理目标对象不用实现接口, 那么注解要是写到接口方法上，要是使用cglib代理，这是注解事物就失效了，为了保持兼容注解最好都写到实现类方法上。 异常详解 那么什么是检查型异常什么又是非检查型异常呢？ 最简单的判断点有两个： 继承自runtimeexception或error的是非检查型异常，而继承自exception的则是检查型异常（当然，runtimeexception本身也是exception的子类）。 对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。所以必须在service捕获异常，然后再次抛出，这样事务方才起效。 源码分析 123456789101112131415161718192021@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepositoryImplementation&lt;T, ID&gt; &#123; private static final String ID_MUST_NOT_BE_NULL = \"The given id must not be null!\"; ………… @Transactional public void deleteById(ID id) &#123; Assert.notNull(id, ID_MUST_NOT_BE_NULL); delete(findById(id).orElseThrow(() -&gt; new EmptyResultDataAccessException( String.format(\"No %s entity with id %s exists!\", entityInformation.getJavaType(), id), 1))); &#125; @Override public T getOne(ID id) &#123; Assert.notNull(id, ID_MUST_NOT_BE_NULL); return em.getReference(getDomainClass(), id); &#125; SimpleJpaRepository在类上添加注解@Transactional(readOnly = true)，默认get*开头的方法都是只读模式，不能更新，删除，而save*,delete*等方法都再次添加注解@Transactional，readOnly默认值为false 以上有部分内容参考Spring Boot多数据源配置与使用","categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://andymeng2017.github.io/tags/springboot/"},{"name":"jpa","slug":"jpa","permalink":"http://andymeng2017.github.io/tags/jpa/"}]},{"title":"Spring Boot系列（一）Spring-data-jpa 访问数据","slug":"spring boot/Spring Boot系列（一）Spring-data-jpa访问数据","date":"2019-08-26T11:34:33.000Z","updated":"2021-06-10T09:07:44.989Z","comments":true,"path":"2019/08/26/spring boot/Spring Boot系列（一）Spring-data-jpa访问数据/","link":"","permalink":"http://andymeng2017.github.io/2019/08/26/spring boot/Spring Boot系列（一）Spring-data-jpa访问数据/","excerpt":"Spring-data-jpa 访问数据由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。 使用示例工程配置在pom.xml中添加相关依赖，加入以下内容：","text":"Spring-data-jpa 访问数据由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。 使用示例工程配置在pom.xml中添加相关依赖，加入以下内容： 1234&lt;dependency &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 在application.xml中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下： 12345678spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=create-dropspring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql = true spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 spring.jpa.database-platform，其作用是：指定mysql的存储引擎为：innodb 例如使用oracle的情况如下： 123456789101112131415161718192021#数据库oracle配置spring.datasource.driver-class-name = oracle.jdbc.driver.OracleDriverspring.datasource.url = jdbc:oracle:thin:@10.0.6.138:1521:xespring.datasource.username = PINGAN_OPENAPIspring.datasource.password = 123456spring.jpa.hibernate.ddl-auto = updatespring.jpa.show-sql = true# Hikari will use the above plus the following to setup connection poolingspring.datasource.type = com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle = 5spring.datasource.hikari.maximum-pool-size = 15spring.datasource.hikari.auto-commit = truespring.datasource.hikari.idle-timeout = 30000spring.datasource.hikari.pool-name = DatebookHikariCPspring.datasource.hikari.max-lifetime = 1800000spring.datasource.hikari.connection-timeout = 30000#mysql或者oracle这里配置不一样#spring.datasource.hikari.connection-test-query = SELECT 1spring.datasource.hikari.connection-test-query = SELECT 1 FROM DUAL 创建实体通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.sinovoice.hcicloud.dto;import com.fasterxml.jackson.annotation.JsonView;import com.sinovoice.hcicloud.validator.MyConstraint;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.CacheConcurrencyStrategy;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.GenericGenerator;import javax.persistence.*;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.Past;import java.util.Date;@Data@NoArgsConstructor@AllArgsConstructor@Entity@Table(name = \"test_user\")public class User &#123; public interface UserSimpleView &#123;&#125;; public interface UserDetailView extends UserSimpleView &#123;&#125;; /** * 逻辑主键 */ @Id @GenericGenerator(name = \"hibernate-uuid\", strategy = \"uuid\") @GeneratedValue(generator = \"hibernate-uuid\") @Column(name = \"UUID\", length = 32, nullable = false, insertable = true, updatable = false) private String id; /** * 因为设置了 unique 为true，会生成默认唯一索引 */ @MyConstraint(message = \"这是一个测试\") @Column(name = \"USERNAME\", length = 64, nullable = false, unique = true) private String username; @NotEmpty(message = \"密码不能为空\") @Column(name = \"PASSWORD\", length = 1000, nullable = false) private String password; @Past(message = \"生日必须是过去的时间\") @Temporal(TemporalType.TIMESTAMP) @Column(name = \"BIRTHDAY\", updatable = false) @CreationTimestamp private Date birthday; @JsonView(UserSimpleView.class) public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @JsonView(UserSimpleView.class) public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; @JsonView(UserDetailView.class) public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @JsonView(UserSimpleView.class) public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id='\" + id + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", birthday=\" + birthday + '&#125;'; &#125;&#125; 创建数据访问接口下面针对SendSuccessLog实体创建对应的Repository接口实现对该实体的数据访问，如下代码： 123456789101112131415161718192021222324252627282930package com.sinovoice.hcicloud.service.repository;import com.sinovoice.hcicloud.dto.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;/** * @Author: mhn * @Date: 2019/6/19 23:11 * @Version 1.0 * @Software: IntelliJ IDEA */@Repositorypublic interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; User findByUsername(String name); User findByUsernameAndPassword(String name, String password); @Query(\"from User u where u.username=:username\") User findUser(@Param(\"username\") String username); //自定义repository。手写sql @Query(value = \"update User set username=?1 where id=?4\",nativeQuery = true) //占位符传值形式 @Modifying int updateById(String name,String id);&#125; 在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。 下面对上面的UserRepository做一些解释，该接口继承自JpaRepository，通过查看JpaRepository接口的API文档，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。 在我们实际开发中，JpaRepository接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。 在上例中，我们可以看到下面两个函数： User findByName(String name) User findByNameAndAge(String name, Integer age) 它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：通过解析方法名创建查询。 除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。 定义service层的接口1234567891011121314151617181920212223242526272829303132333435363738package com.sinovoice.hcicloud.service;import com.sinovoice.hcicloud.dto.User;import java.util.Iterator;/** * @Author: mhn * @Date: 2019/6/19 23:20 * @Version 1.0 * @Software: IntelliJ IDEA */public interface UserServiceJpa &#123; /** * 删除 */ void delete(String id); /** * 增加 */ void insert(User user); /** * 更新 */ int update(User user); /** * 查询单个 */ User selectById(String id); /** * 查询全部列表 */ Iterator&lt;User&gt; selectAll(int pageNum, int pageSize);&#125; 定义service层的实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.sinovoice.hcicloud.service.impl;import com.sinovoice.hcicloud.dto.User;import com.sinovoice.hcicloud.service.UserServiceJpa;import com.sinovoice.hcicloud.service.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.stereotype.Service;import java.util.Iterator;import java.util.Optional;/** * @Author: mhn * @Date: 2019/6/19 23:21 * @Version 1.0 * @Software: IntelliJ IDEA */@Servicepublic class UserServiceJpaImpl implements UserServiceJpa &#123; @Autowired private UserRepository userRepository; /** * 删除 * * @param id */ @Override public void delete(String id) &#123; userRepository.deleteById(id); &#125; /** * 增加 * * @param user */ @Override public void insert(User user) &#123; userRepository.save(user); &#125; /** * 更新 * * @param user */ @Override public int update(User user) &#123; userRepository.save(user); return 1; &#125; /** * 查询单个 * * @param id */ @Override public User selectById(String id) &#123; Optional&lt;User&gt; optional = userRepository.findById(id); User user = optional.get(); return user; &#125; /** * 查询全部列表,并做分页 * @param pageNum 开始页数 * @param pageSize 每页显示的数据条数 */ @Override public Iterator&lt;User&gt; selectAll(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 Sort sort = new Sort(Sort.Direction.DESC, \"id\"); Pageable pageable = new PageRequest(pageNum, pageSize, sort); Page&lt;User&gt; users = userRepository.findAll(pageable); Iterator&lt;User&gt; userIterator = users.iterator(); return userIterator; &#125;&#125; 单元测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.sinovoice.hcicloud.service;import com.sinovoice.hcicloud.dto.User;import com.sinovoice.hcicloud.service.repository.UserRepository;import lombok.extern.slf4j.Slf4j;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.time.LocalDateTime;import java.util.Date;import java.util.Iterator;/** * 测试的时候，要注释掉 MyConstraintValidator#helloService 依赖，不然会失败 * @Author: mhn * @Date: 2019/6/19 22:49 * @Version 1.0 * @Software: IntelliJ IDEA */@Slf4j@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserServiceJpaTest &#123; @Autowired private UserServiceJpa userSerivceJpa; @Test public void test() throws Exception &#123; User user = new User(); user.setUsername(\"mhn1\"); user.setPassword(\"123456\"); user.setBirthday(new Date()); userSerivceJpa.insert(user); User user1 = new User(); user1.setUsername(\"mhn2\"); user1.setPassword(\"123456\"); user1.setBirthday(new Date()); userSerivceJpa.insert(user1); Iterator&lt;User&gt; userIterator = userSerivceJpa.selectAll(1, 10); while (userIterator.hasNext())&#123; User user2 = userIterator.next(); userSerivceJpa.delete(user2.getId()); &#125; &#125;&#125;","categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://andymeng2017.github.io/tags/springboot/"},{"name":"jpa","slug":"jpa","permalink":"http://andymeng2017.github.io/tags/jpa/"}]},{"title":"mysql系列（一）","slug":"mysql/mysql系列（一）balabala","date":"2019-08-17T03:44:17.000Z","updated":"2021-06-10T09:07:44.988Z","comments":true,"path":"2019/08/17/mysql/mysql系列（一）balabala/","link":"","permalink":"http://andymeng2017.github.io/2019/08/17/mysql/mysql系列（一）balabala/","excerpt":"mysql系列（一）查看表空间大小","text":"mysql系列（一）查看表空间大小","categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://andymeng2017.github.io/tags/mysql/"}]},{"title":"Oracle系列（一）日常sql语句","slug":"oracle/Oracle系列（一）日常sql语句","date":"2019-08-17T03:25:56.000Z","updated":"2021-06-10T09:07:44.989Z","comments":true,"path":"2019/08/17/oracle/Oracle系列（一）日常sql语句/","link":"","permalink":"http://andymeng2017.github.io/2019/08/17/oracle/Oracle系列（一）日常sql语句/","excerpt":"Oracle系列（一）日常sql语句查看表空间大小","text":"Oracle系列（一）日常sql语句查看表空间大小 1234567891011select b.file_id 文件ID, b.tablespace_name 表空间, b.file_name 物理文件名, b.bytes/1024/1024/1024 总字节数(GB), (b.bytes-sum(nvl(a.bytes,0))) 已使用, sum(nvl(a.bytes,0)) 剩余, sum(nvl(a.bytes,0))/(b.bytes)*100 剩余百分比from dba_free_space a,dba_data_files bwhere a.file_id=b.file_idgroup by b.tablespace_name,b.file_name,b.file_id,b.bytesorder by b.tablespace_name 查看表空间（方式二）1234567891011121314151617181920--1G=1024MB --1M=1024KB --1K=1024Bytes --1M=11048576Bytes --1G=1024*11048576Bytes=11313741824Bytes SELECT a.tablespace_name \"表空间名\", total \"表空间大小\", free \"表空间剩余大小\", (total - free) \"表空间使用大小\", total / (1024 * 1024 * 1024) \"表空间大小(G)\", free / (1024 * 1024 * 1024) \"表空间剩余大小(G)\", (total - free) / (1024 * 1024 * 1024) \"表空间使用大小(G)\", round((total - free) / total, 4) * 100 \"使用率 %\" FROM (SELECT tablespace_name, SUM(bytes) free FROM dba_free_space GROUP BY tablespace_name) a, (SELECT tablespace_name, SUM(bytes) total FROM dba_data_files GROUP BY tablespace_name) b WHERE a.tablespace_name = b.tablespace_name 查看版本号1select * from v$version; 查看可能出现oracle ORA-01461 错误 can bind a LONG value only for insert into a LONG column的表12345678910111213SELECT * FROM (SELECT TABLE_NAME, OWNER, count(*) NUM FROM DBA_TAB_COLUMNS WHERE DATA_TYPE='LONG' OR (( DATA_TYPE='VARCHAR2' or DATA_TYPE='CHAR' or DATA_TYPE='NVARCHAR2' or DATA_TYPE='NCHAR') AND DATA_LENGTH &gt; 1333) AND OWNER NOT IN ('SYS','SYSTEM','SH','OLAPSYS','MDSYS','WKSYS','ODM','XDB','WMSYS') GROUP BY TABLE_NAME, OWNER) WHERE NUM &gt; 1; user_tables(当前用户下所有的表)1select count(*) from user_tables; 查看所有用户1select distinct owner from all_objects; 查看当前用户表空间1select default_tablespace from dba_users where username='PINGAN_OPENAPI'; 授予LNCHDPSQP可以查看SYNCHRO_PRODUCE_TIME_TEST1grant select on SYNCHRO_PRODUCE_TIME_TEST to LNCHDPSQP; 清空表1truncate table ** 查看连接数1select count(*) from v$session; 大数据批量更新12345678910111213141516171819202122232425262728293031323334353637383940declare cursor cur is--声明游标cur select B.\"big_name\", A.\"UUID\" ROW_ID FROM STATISTICS_REAL_TIME_ANALYSIS A ,\"HCICLOUD\".\"big_small_temp\" B WHERE A.\"KEY\"=B.\"small_name\" ORDER BY A.\"UUID\";--从A和B表中找到ID对应的openid，并对游标内数组排序 V_COUNTER NUMBER;--声明一个number类型的变量BEGIN V_COUNTER:=0;--初始化变量值为0 FOR ROW IN CUR LOOP--遍历游标 UPDATE STATISTICS_REAL_TIME_ANALYSIS A SET A.\"BIG_KEY\"=ROW.\"big_name\" WHERE A.\"UUID\"=ROW.ROW_ID; V_COUNTER:=V_COUNTER+1;--每次循环变量值+1 IF(V_COUNTER&gt;=1000) THEN COMMIT; V_COUNTER:=0;--每更新1000行，V_COUNTER值为1000时候，就提交给数据库,提交后将变量归零，继续下一个1000行更新 END IF; END LOOP; COMMIT;END;注意：关联字段A.\"KEY\" 和 A.\"UUID\" 一定要加索引测试结果：152w(8s)单表更新declare cursor cur is--声明游标cur SELECT UUID FROM SEND_SUCCESS_LOG; V_COUNTER NUMBER;--声明一个number类型的变量BEGIN V_COUNTER:=0;--初始化变量值为0 FOR ROW IN CUR LOOP--遍历游标 UPDATE SEND_SUCCESS_LOG A SET A.\"VERSION\"=0 WHERE A.\"UUID\"=ROW.UUID; V_COUNTER:=V_COUNTER+1;--每次循环变量值+1 IF(V_COUNTER&gt;=1000) THEN COMMIT; V_COUNTER:=0;--每更新1000行，V_COUNTER值为1000时候，就提交给数据库,提交后将变量归零，继续下一个1000行更新 END IF; END LOOP; COMMIT;END; 查看USERS表空间的全部索引，同时排序1select segment_name,tablespace_name,bytes B, bytes/1024 KB, bytes/1024/1024 MB from user_segments where segment_type='INDEX' and tablespace_name='USERS' ORDER BY bytes desc; 查看USERS表空间的全部表，同时排序1select segment_name,tablespace_name,bytes B, bytes/1024 KB, bytes/1024/1024 MB from user_segments where segment_type='TABLE' and tablespace_name='USERS' ORDER BY bytes desc; 查看表所在的表空间1select tablespace_name,table_name from user_tables where table_name='STATISTICS_REAL_TIME_ANALYSIS'; 查看USERS表空间下的表1select TABLE_NAME,TABLESPACE_NAME from dba_tables where TABLESPACE_NAME='USERS'; 查看STATISTICS_REAL_TIME_ANALYSIS表占用的大小12345select t.segment_name, t.segment_type, sum(t.bytes / 1024 / 1024) \"占用空间(M)\"from dba_segments twhere t.segment_type='TABLE'and t.segment_name='STATISTICS_REAL_TIME_ANALYSIS'group by OWNER, t.segment_name, t.segment_type; 查看USERS表空间下的表的大小1234select segment_name,tablespace_name,bytes B, bytes/1024 KB, bytes/1024/1024 MB from user_segments where segment_type='TABLE' and tablespace_name='USERS' ORDER BY bytes desc; 查看TS_JIETONG_INFO表空间下索引大小1234select segment_name,tablespace_name,bytes B, bytes/1024 KB, bytes/1024/1024 MB from user_segments where segment_type='INDEX' and tablespace_name='TS_JIETONG_INFO' ORDER BY bytes desc; 迁移索引‘INDEX_JANUARY_CALL_ID’到新表空间1alter index INDEX_JANUARY_CALL_ID rebuild tablespace TS_JIETONG_INFO; 迁移表‘STATISTICS_TA_ANALYSIS’到新表空间1alter table STATISTICS_TA_ANALYSIS move tablespace TS_JIETONG_INFO; 查看索引状态1SELECT OWNER, INDEX_NAME,STATUS FROM ALL_INDEXES WHERE INDEX_NAME='INDEX_APR'; 新建索引12create index HW_AGENTINFO_AGENTID on T_HW_AGENTINFO(AGENTID) tablespace TS_JIETONG_INFO;create index INDEX_APRIL_AGENTID on CALL_APRIL_HISTORY(AGENTID,CALL_PHONE) tablespace TS_JIETONG_INFO; case-when 使用123456789101112131415161718192021222324252627282930SELECT MOD (TO_CHAR(SYSDATE, 'ss'), 2) AS i, COUNT (*)FROM SEND_ACCESS_LOGWHERE OPEN_API_CREATE_TIME BETWEEN TO_DATE ( SYSDATE -- '2019-06-04 00:00:00', -- 'yyyy-mm-dd hh24:mi:ss' )AND TO_DATE ( SYSDATE + 1 -- '2019-06-05 00:00:00', -- 'yyyy-mm-dd hh24:mi:ss')AND ( ( MOD (TO_CHAR(SYSDATE, 'ss'), 2) = '0' AND SUCCESSSEND_CODE = '0' ) OR ( MOD (TO_CHAR(SYSDATE, 'ss'), 2) = '1' -- AND SUCCESSSEND_CODE IS NULL )) -- (-- CASE-- WHEN MOD (TO_CHAR(SYSDATE, 'ss'), 2) = '0' THEN-- '0'-- ELSE-- null-- END-- ) 按照时间月份分组查询123456789SELECT TO_CHAR (CREATE_TIME, 'yyyy-mm') time, COUNT (*)FROM STATISTICS_REAL_TIME_ANALYSISGROUP BY TO_CHAR (CREATE_TIME, 'yyyy-mm')ORDER BY time;","categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://andymeng2017.github.io/tags/oracle/"}]},{"title":"Hexo适配hexo-theme-hipaper主题","slug":"hexo/Hexo适配hexo-theme-hipaper主题","date":"2019-08-13T03:30:24.000Z","updated":"2021-06-10T09:07:44.988Z","comments":true,"path":"2019/08/13/hexo/Hexo适配hexo-theme-hipaper主题/","link":"","permalink":"http://andymeng2017.github.io/2019/08/13/hexo/Hexo适配hexo-theme-hipaper主题/","excerpt":"Hexo适配hexo-theme-hipaper主题 hexo官方网站 Node.js (Should be at least nodejs 6.9) Git 开始使用本地环境安装完毕后执行命令hexo version，查看是否成功","text":"Hexo适配hexo-theme-hipaper主题 hexo官方网站 Node.js (Should be at least nodejs 6.9) Git 开始使用本地环境安装完毕后执行命令hexo version，查看是否成功 123456789101112131415161718$ hexo --versionhexo-cli: 2.0.0os: Windows_NT 6.1.7601 win32 x64http_parser: 2.8.0node: 10.16.2v8: 6.8.275.32-node.54uv: 1.28.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 4openssl: 1.1.1cicu: 64.2unicode: 12.1cldr: 35.1tz: 2019a 建站这里可以理解为建立本地仓库环境 folder为指定的目录环境 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 更多命令见官方文档，挺全的 获取指定的主题Get it from Github在你建站指定的 folder目录 $ git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git themes/hipaper Enable 启用主题修改配置文件_config.yml的主题 123456# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#默认主题#theme: landscapetheme: hipaper Update 更新主题12$ cd themes/hipaper$ git pull 配置 针对根目录配置文件修的修改 部署安装 hexo-deployer-git 1`$ npm install hexo-deployer-git --save` 修改配置文件_config.yml的Deployment 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/AndyMeng2017/andymeng2017.github.io.git branch: master 站点信息修改修改配置文件_config.yml的Site 12345678# Sitetitle: Andy Mengsubtitle:description: How many roads must a man walk down.keywords:author: John Doe|Andy Menglanguage: entimezone: 针对主题目录下配置文件修的修改 logo图标123456789# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 #url: https://hexo.io/logo.svg url: css/images/mylogo.jpg 社交信息12345678910111213# Social Links# Key is the name of FontAwsome icon.# Value is the target link (E.g. GitHub: https://github.com/iTimeTraveler)social: Github: https://github.com/AndyMeng2017 Weibo: https://weibo.com/u/1962585291 Twitter: Facebook: Google-plus: Instagram: Pinterest: Flickr: email: 707093428@qq.com 评论1234567# comment ShortName, you can choose only ONE to display.duoshuo_shortname: disqus_shortname: #livere_shortname: MTAyMC8yOTQ4MS82MDQ5livere_shortname: MTAyMC80NTk0OC8yMjQ1OQ==uyan_uid: wumii: 不蒜子12345678910# Miscellaneousgoogle_analytics:gauges_analytics:baidu_analytics:tencent_analytics:busuanzi_analytics: truetwitter:google_plus:fb_admins:fb_app_id: 模板里域名过期，需要修改 themes\\hipaper\\layout\\_partial\\busuanzi-analytics.ejs文件 1234&lt;% if (theme.busuanzi_analytics)&#123; %&gt; &lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt; &lt;/script&gt;&lt;% &#125;%&gt; CNZZ123# CNZZ count# cnzz_siteid: 1260716016cnzz_siteid: 1277912853 这里很尴尬的说，主题作者可能忘记删掉一些代码，故修改 themes\\hipaper\\layout_partial\\after-footer.ejs`文件，删掉一下信息 123&lt;div style=\"display: none;\"&gt; &lt;script src=\"https://s11.cnzz.com/z_stat.php?id=1260716016&amp;web_id=1260716016\" language=\"JavaScript\"&gt;&lt;/script&gt;&lt;/div&gt; 发布部署在根目录执行 hexo g -d 附件： 评论插件截图，这软件很棒","categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://andymeng2017.github.io/tags/Hexo/"}]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-08-09T09:35:25.000Z","updated":"2021-06-10T09:07:44.989Z","comments":true,"path":"2019/08/09/post-title-with-whitespace/","link":"","permalink":"http://andymeng2017.github.io/2019/08/09/post-title-with-whitespace/","excerpt":"","text":"这里是正文","categories":[],"tags":[]}],"categories":[{"name":"blog","slug":"blog","permalink":"http://andymeng2017.github.io/categories/blog/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://andymeng2017.github.io/tags/springboot/"},{"name":"jpa","slug":"jpa","permalink":"http://andymeng2017.github.io/tags/jpa/"},{"name":"mysql","slug":"mysql","permalink":"http://andymeng2017.github.io/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"http://andymeng2017.github.io/tags/oracle/"},{"name":"Hexo","slug":"Hexo","permalink":"http://andymeng2017.github.io/tags/Hexo/"}]}